# Worker Pool в Go (Аналог Celery)

## Концепция
**Worker Pool (Пул воркеров)** — это паттерн управления конкурентностью.

Вместо того чтобы создавать новую горутину на каждую задачу (что может привести к исчерпанию ресурсов при резком скачке нагрузки), мы создаем фиксированное количество "воркеров" (горутин), которые обрабатывают задачи из общей очереди (канала).

## Сравнение с Django + Celery

| Характеристика | Django + Celery | Go (Goroutines/Channels) |
| :--- | :--- | :--- |
| **Архитектура** | Распределенная (App + Broker + Worker Process) | Монолитная (App + Goroutines) |
| **Сложность** | Высокая (нужен Redis/RabbitMQ) | Низкая (все внутри приложения) |
| **Ресурсы** | Высокие (Python потоки/процессы тяжелые) | Очень низкие (Горутины весят килобайты) |
| **Надежность** | **Высокая** (Задачи хранятся в Redis, переживут рестарт) | **Средняя** (Задачи в памяти (RAM), пропадут при рестарте) |

> **Примечание:** Если задачи критичны (финансы), в Go тоже подключают RabbitMQ/Kafka, но для фоновых задач вроде рассылок встроенных средств обычно достаточно.

## Пример реализации

```go
package main

import (
	"fmt"
	"time"
)

// Job - описание задачи (например, данные для письма)
type Job struct {
	ID    int
	Email string
}

func main() {
	// 1. Создаем канал задач (наша очередь в памяти).
	// Буфер 100 означает, что можно накидать 100 задач в очередь,
	// не дожидаясь, пока воркеры их разберут.
	jobs := make(chan Job, 100)

	// 2. Запускаем фиксированное количество воркеров (например, 3)
	// Они будут жить все время работы приложения
	for w := 1; w <= 3; w++ {
		go worker(w, jobs)
	}

	// 3. Имитируем отправку задач (например, из HTTP хендлера)
	for i := 1; i <= 10; i++ {
		fmt.Printf("Добавляем задачу %d\n", i)
		jobs <- Job{ID: i, Email: fmt.Sprintf("user%d@test.com", i)}
	}

	// В реальном сервере здесь будет http.ListenAndServe
	time.Sleep(5 * time.Second)
}

// worker - функция, которая крутится в фоне и слушает канал
func worker(id int, jobs <-chan Job) {
	// range jobs будет читать из канала, пока он открыт
	for j := range jobs {
		fmt.Printf("[Воркер %d] Начал обработку: %s\n", id, j.Email)
		time.Sleep(1 * time.Second) // Имитация тяжелой работы (SMTP запрос)
		fmt.Printf("[Воркер %d] Готово!\n", id)
	}
}
```
